\documentclass{pracamgr}

\usepackage{polski}
\usepackage{graphicx}
\usepackage{todonotes}
\usepackage{hyperref}

\usepackage[utf8]{inputenc}

% Dane magistranta:

\author{Marcel Kołodziejczyk}

\nralbumu{219533}

\title{Luki w bezpieczeństwie systemu operacyjnego Android}

\tytulang{Vulnerabilities in Android operating system}

%kierunek: Matematyka, Informatyka, ...
\kierunek{Informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dra Marcina Peczarskiego\\
  Instytut Informatyki\\
  }

% miesiąc i~rok:
\date{Czerwiec 2013}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{
%11.0 Matematyka, Informatyka:\\
%11.1 Matematyka\\
%11.2 Statystyka\\
11.3 Informatyka\\
%11.4 Sztuczna inteligencja\\
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.4. Operating Systems\\
  D.4.6. Security and Privacy Protection}

% Słowa kluczowe:
\keywords{android, arm, atak, bezpieczeństwo, przepełnienie bufora, metasploit, exploit, shellcode}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}
\maketitle


%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
krótkie streszczenie pracy
\end{abstract}


\tableofcontents
%\listoffigures
%\listoftables
\listoftodos

\chapter*{Wprowadzenie}

\chapter{Platforma sprzętowa i programowa}

Android jest systemem operacyjnym i zestawem aplikacji dedykowanym przede wszystkim dla urządzeń przenośnych z ekranami dotykowymi, takimi jak np. smartphone, tablet. 
Jądro systemu, zostało oparte na jądrze Linuksa. System ten został zaprojektowany i stworzony głównie z myślą o urządzeniach
wyposażonych w procesor w architekturze ARM, aczkolwiek podejmowane są prace nad dostosowaniem Androida do innych architektur, np. x86.

W rozdziale tym zostaną opisane podstawy architektury procesorów ARM. Następnie zostanie omówiona architektura oraz model bezpieczeństwa systemu Android.

\section{Architektura procesorów ARM}

ARM jest 32-bitową architekturą procesorów typu RISC. Główne jej cechy to:
\begin{itemize}
\item proste tryby adresowania
\item instrukcje stałej długości co ułatwia adresowanie
\item architektura typu \emph{load/store} - operacje wykonywane są na rejestrach a nie bezpośrednio na pamięci 
\item duża liczba 32-bitowych rejestrów
\item zredukowana liczba instrukcji
\end{itemize}


Z biegiem czasu ukazywały się kolejne wersje architektury ARM. Niniejsza praca bazuje na wersji 7 (ARMv7), które jest obecnie najbardziej 
powszechnie wykorzystywana w urządzeniach przenośnych.

\subsection{Thumb-2}

Instrukcje ARM są stałej, 32-bitowej długości. W celu zwiększenia gęstości kodu został wprowadzony drugi, uproszczony zestaw 16-bitowych instrukcji Thumb-2. 
Ponieważ w obydwu trybach adresy instrukcji muszą być odpowiednio wyrównane, ostatni bit adresu może być wykorzystany w celu zmiany trybu pracy procesora.
Instrukcja skoku do adresu, którego ostatni bit jest zapalony, wymusza zmianę trybu na Thumb-2 i dalsze wykonywanie instrukcji spod adresu odpowiednio wyrównanego.
Analogicznie instrukcja skoku do parzystego adresu powoduje przejście w 32-bitowy zestaw instrukcji ARM.

\subsection{Rejestry}

Z punktu widzenia programisty dostępnych jest szesnaście 32-bitowych rejestrów R0-R15. Trzy z nich mają dedykowane przeznaczenie:

\begin{itemize}
\item SP (Stack Pointer) - R13 - wskaźnik stosu
\item LR (Link Register) - R14 - zawiera adres następnej instrukcji przy instrukcjach skoku wywołania podprogramu
\item PC (Program Counter) - R15 - przechowuje adres następnej instrukcji
\end{itemize}

Dodatkowo występuje rejestr statusowy procesora CPSR (ang. Current Processor Status Register). Przechowuje on m. in. flagi Negative, Zero, Carry, oVerflow.
Większość instrukcji może być wykonywanych warunkowo, w zależności od stanu tych flag.

Szczegółowe informacje na ten temat można znaleźć w \cite{armman}.

\subsection{Standard wywołania procedur}

Do wykonywania procedur służą następujące instrukcje:
\begin{itemize}
\item \textbf{B} - Branch
\item \textbf{BL} - Branch with Link
\item \textbf{BX} - Branch and Exchange
\item \textbf{BLX} - Branch with Link and Exchange
\end{itemize}

Instrukcja \textit{Branch} umożliwia wykonanie skoku o maksymalnie 32 MB w przód lub w tył od bieżącej instrukcji. \textit{Branch with link} dodatkowo
zachowuje adres powrotu w rejestrze LR (R14). Pozostałe dwie instrukcje jako argument przyjmują rejestr - skok jest wykonywany do adresu, jaki znajduje się
w przekazanym rejestrze.

Architektura ARM określa następujące zasady wywoływania procedur:
\begin{itemize}
\item Do przekazywania argumentów i zwracania wyniku procedury używane są rejestry R0-R3. Kolejne parametry mogą być przekazywane na stosie.
\item rejestry R4-R11 mogą być wykorzystywana do przechowywania zmiennych lokalnych
\item Zawartość rejestrów R4-R12 powinna być zachowana w trakcie wykonania procedury. Zazwyczaj w prologu procedury rejestry te są odkładana na stos, 
aby przywrócić ich wartości w epilogu.
\item Stos rośnie w kierunku mniejszych adresów pamięci.
\end{itemize}

Kompletną dokumentację standardu wołania procedur można znaleźć w \cite{armcall}.

\section{Architektura systemu Android}

% http://www.android-app-market.com/android-architecture.html

Diagram \ref{figure:architektura} przedstawia najważniejsze komponenty systemu Android. Zostaną one w skrócie omówione w kolejnych paragrafach.

\begin{figure}[htb]
\begin{minipage}{\textwidth}
\begin{center}
\includegraphics[width=\textwidth]{system-architecture.jpg} 
\end{center}
\caption[Główne komponenty systemu Android]{Główne komponenty systemu Android \footnotemark }
\label{figure:architektura}
\footnotetext{źródło: \url{http://developer.android.com/about/versions/index.html}}
\end{minipage}
\end{figure}

\subsection{Jądro systemu}

Podstawową warstwą zapewniającą interakcje ze sprzętem jest jądro systemu. Jądro systemu Android od wersji 4.0 (\textit{Ice Cream Sandwich}), stanowi nieznacznie 
zmodyfikowane jądro Linuxa w wersji 3.0.x. Wcześniejsze wydania systemu opierały się na jądrach z linii 2.6.x. Najważniejsze zmiany w stosunku do głównej wersji to:
\begin{itemize}
\item dodatkowe mechanizmy komunikacji międzyprocesowej i zdalnego wołania metod (\textit{Android Binder}),
\item nowy podsystemem pamięci dzielonej \verb+ashmem+ i alokator pamięci \verb+pmem+,
\item \verb+logger+ - wsparcie jądra dla narzędzia \verb+logcat+,
\item dodatkowe mechanizmy ograniczające dostęp do wybranych funkcjonalności sieciowych (\textit{paranoid network security}).
\end{itemize}

Sytuacja, w której jądro Androida jest rozgałęzieniem w stosunku do głównej linii Linuxa jest bardzo istotna z punktu widzenia bezpieczeństwa systemu. Wszelkie zmiany
wprowadzane w jądrze Linuxa, w tym niektóre poprawki bezpieczeństwa, pojawiają się w zmodyfikowanej wersji dla Androida ze sporym opóźnieniem. Dodatkowo opóźnienie to 
jest powiększone przez system aktualizacji systemu, co zostanie opisane w paragrafie \ref{section:aktualizacje}.
Z tego powodu istnieje bardzo wiele powszechnie znanych luk w jądrze Androida, pozwalających m. in. na eskalację uprawnień procesu. Pozwala to na tymczasowe lub permanentne 
uzyskanie uprawnień administratora systemu (tzn. ,,rootowanie'' systemu). Jest to bardzo często wykorzystywane przez zwykłych użytkowników do wykonania niektórych czynności 
administracyjnych, np. zmiany konfiguracji systemu, odinstalowanie wybranych aplikacji systemowych, a nawet wgranie zupełnie nowego obrazu systemu. Istnieje wiele narzędzi 
umożliwiających wykonanie tego procesu zwykłemu, niezaawansowanemu użytkownikowi.

\subsection{Biblioteki}

System Android posiada szereg popularnych bibliotek napisanych w C/C++, używanych przez różne komponenty poprzez ,,framework'' aplikacji. Możliwe jest także 
skorzystanie z tych bibliotek w kodzie natywnym napisanym w C/C++. Przykładowe biblioteki to:

\begin{itemize}
\item \verb+libc+ - standardowa biblioteka C, zoptymalizowana dla urządzeń wbudowanych,
\item \verb+webcore+ - silnik przeglądarki internetowej. Może być wykorzystany w innych aplikacjach, które potrzebują wyświetlić stronę HTML, mp. w kliencie poczty e-mail,
\item \verb+sqllite+ - lekka relacyjna baza danych,
\item \verb+OpenGL+ - używana podczas renderowania grafiki dwu- i trójwymiarowej,
\item zestaw bibliotek multimedialnych dostarczających kodeki wybranych formatów plików.
\end{itemize}

\subsection{Środowisko czasu wykonania}

Środowisko czasu wykonania systemu Android składa się z maszyny wirtualnej Dalvik oraz podstawowych bibliotek Javy.

Dalvik jest maszyną wirtualną, która została stworzona specjalnie dla systemu Android, w celu zapewnienia odpowiedniej wydajności na urządzeniach z mniejszymi
zasobami, jak np. telefony komórkowe. Nie jest maszyną wirtualną Javy i używa własnego kodu bajtowego w formacie \verb+.dex+ (Dalvik executable). Możliwa jest 
jednak konwersja kodu bajtowego Javy do kodu Dalvika. W przeciwieństwie do wirtualnej maszyny Javy, która jest maszyną stosową, Dalvik jest maszyną rejetrową.
Dalvik umożliwia uruchomienie wielu aplikacji jednocześnie tworząc klika instancji maszyny wirtualnej. Zapewnia izolację, zarządzanie pamięcią oraz wielowątkowość. 

\subsection{Aplikacje}

System Android posiada kilka podstawowych aplikacji zapewniających podstawowe funkcjonalności nowoczesnego telefonu komórkowego, np. klient SMS, aplikacja 
do wykonywania połączeń głosowych, klient poczty, przeglądarka internetowa, zarządca aplikacji. Bardzo wiele funkcjonalności jest wydzielonych do osobnych komponentów tworząc
tzn. ,,framework''. Jest on zaprojektowany w sposób, który umożliwia zastąpienie jego dowolnego komponentu na inny zapewniający taką samą funkcjonalność.


\section{Model bezpieczeństwa Androida}

Platforma Android została zaprojektowana w taki sposób, aby możliwe było także zainstalowanie aplikacji z potencjalnie niezaufanych źródeł.
Jest to odmienny model niż w przypadku telefonów iPhone (z systemem operacyjnym iOS), gdzie wszystkie aplikacje mogą być jedynie zainstalowane
z jednego źródła (\textit{Apple store}) i mogą być zweryfikowane przed upublicznieniem. Z tego powodu system Android posiada mechanizmy bezpieczeństwa 
działające na wielu poziomach. Izolowanie aplikacji wykorzystuje mechanizmy kontroli dostępu do systemu plików, jakie udostępnia jądro Linuxa oraz 
mechanizm nadawania wybranych uprawnień zatwierdzanych przez użytkownika w trakcie instalacji aplikacji. Aplikacje muszą być także podpisane przy użyciu 
kryptografii klucza publicznego, jednak ten mechanizm umożliwia jedynie wiarygodne zidentyfikowanie autora aplikacji.

System Android zbudowany jest na bazie standardowego jądra Linuxa z nieznacznymi modyfikacjami, dlatego też 
posiada uznaniową kontrolę dostępu (\textit{Discretionary Access Control - DAC}) na poziomie systemu plików, która opiera się na identyfikatorach 
użytkowników (\textit{uid}) i grup (\textit{gid}). Nad jądrem Android używa własnego zbioru bibliotek i usług. Aplikacje mogą być tworzone w Javie
i są kompilowane do kodu bajtowego maszyny wirtualnej Dalvik. Aplikacje lub fragmenty mogą być również tworzone w C/C++ a następnie wywoływane z Javy
poprzez interfejs JNI (\textit{Java Native Interface}).

\subsection{Uruchamianie aplikacji w \textit{,,piaskownicy''}}\label{subsection:piaskownica}

Aplikacje zainstalowane w systemie są ograniczone w \textit{,,piaskownicy''}, która jest zdefiniowana poprzez unikalny \textit{uid} i odpowiadający \textit{gid}.
Identyfikatory te są tworzone dynamicznie podczas instalowania aplikacji. Nazwy użytkownika i grupy są identyczne i składają się z prefiksu \verb+app_+ oraz identyfikatora.
Każda aplikacja używa innego identyfikatora użytkownika i grupy, co gwarantuje pełną izolację na poziomie systemu plików. Dostęp do plików i usług systemowych jest 
także znacząco ograniczony, zazwyczaj tylko do odczytu. Wywołanie funkcji lub usługi spoza \textit{,,piaskownicy''} jest możliwe poprzez odpowiednie API, które 
wymaga odpowiednich uprawnień aplikacji, co zostanie opisanie w punkcie \ref{subsection:uprawnienia}.

Ograniczenia \textit{,,piaskownicy''} są wymuszane przed jądro systemu i poprzez odpowiednie usługi przestrzeni użytkownika, dlatego też dotyczą wszystkich aplikacji, 
włącznie z kodem natywnym wywoływanym bezpośrednio poprzez interfejs JNI lub przy użyciu wywołania systemowego \verb+exec+. Jeżeli aplikacje potrzebują współdzielić dane, 
na przykład na poziomie systemu plików, powinny zadeklarować wspólny identyfikator użytkownika (\textit{uid}) w manifeście. Jest to możliwe tylko wtedy, gdy aplikację 
są podpisane przy użyciu tego samego klucza prywatnego. Identyfikatory użytkowników i odpowiadające im uprawnienia są przechowywane w pliku \verb+data/system/packages.xml+
i są do odczytu przez wszystkie aplikacje zainstalowane na urządzeniu.

\subsection{Kontrola dostępu do systemu plików}

Uznaniowa kontrola dostępu do systemu plików w Androidzie jest zrealizowana przy użyciu tradycyjnych Unixowych uprawnień. Pliki tworzone przez aplikacje domyślnie mają
ustawione uprawnienia na \verb+rw-rw----+ (0660 w notacji ósemkowej). Z tego powodu aplikacje zainstalowane z różnymi identyfikatorami użytkownika i grupy nie mogą czytać,
modyfikować ani wykonywać wzajemnie swoich plików. Pliki mogą być jednak jawnie udostępniane poprzez użycie flag \verb+MODE_WORLD_READABLE+ i \verb+MODE_WORLD_WRITABLE+
podczas tworzenia ich w API Javowym lub poprzez wywołanie systemowe \verb+chmod+ w natywnym kodzie C/C++. Tworzenie plików z odpowiednimi uprawnieniami leży w gestii
aplikacji.

Katalog z danymi aplikacji domyślnie znajduje się w \verb+/data/data/<nazwa pakietu>/+ i posiada następującą strukturę:
\begin{itemize}
\item \verb+databases+ - domyślny katalog do przechowywania baz danych sqlite
\item \verb+lib+ - zawiera wszystkie natywne biblioteki używane przez aplikacje, skopiowane podczas instalacji
\item \verb+files+ - jest to katalog, gdzie domyślnie są tworzone pliki przez aplikację
\item \verb+shared_prefs+ - zawiera XML-owe pliki konfiguracyjne aplikacji
\end{itemize}

Standardowe, pre-instalowane aplikacje (np. \verb+com.android.camera+) zazwyczaj także używają powyższej struktury katalogów, jednak ich lokalizacja może być odmienna
na niektórych urządzeniach, np. telefony marki \textit{Samsung} używają ścieżki \verb+/dbdata/databases/<nazwa pakietu>/+ dla pre-instalowanych aplikacji. Jest to istotnie 
z punktu widzenia twórcy exploitów, aby złośliwy kod potrafił się dostosować do struktury katalogów używanej przez dane urządzenie.

W trakcie rozruchu systemu różne części systemu plików są montowane z odmiennymi opcjami. Katalog \verb+/data+ używa opcji \verb+'rw,nosuid,nodev,relatime'+, co m. in. 
oznacza, że flaga plików \verb+setuid+ nie będzie respektowana. Pliki wykonywalne będą zawsze uruchamiane z uprawnieniami użytkownika wykonującego program, a nie właściciela pliku.


Katalog \verb+/system+ jest montowany z opcjami \verb+ro,relatime+, co powoduje, że cała partycja jest jedynie do odczytu. Warto zwrócić uwagę, że w tym przypadku opcja \verb+nosuid+
nie jest używana, ponieważ system Android korzysta z plików z flagą \verb+setuid+ w tej lokalizacji.

\subsection{Uprawnienia aplikacji}\label{subsection:uprawnienia}

Aplikacje w celu wyjścia z \textit{,,piaskownicy''} (zarówno na poziomie systemu pików, jak i wywoływania chronionych funkcji API systemu), muszą mieć wcześniej nadane 
odpowiednie uprawnienia. Wymagane przez aplikację funkcjonalności są wyświetlane w trakcie instalacji i muszą być zatwierdzone przez użytkownika. Nie jest jednak możliwe 
selektywne wybranie uprawnień. 

Aplikacja, aby uzyskać dostęp do chronionych funkcji API, musi zawierać uprawnienia, takie jak na przykład:

\begin{verbatim}
<uses-permission android:name="android.permission.CALL_PHONE" />
\end{verbatim}

w pliku \verb+AndroidManifest.xml+. Każda próba wykonania chronionej funkcji API bez odpowiednich uprawnień spowoduje podniesienie wyjątku \verb+SecurityException+.

\subsection{Podpisywanie aplikacji}

Każda instalowana aplikacja w systemie Android musi być podpisana przez twórcę przy użyciu klucza prywatnego wraz z odpowiadającym certyfikatem. Możliwe jest jednak używanie
kluczy prywatnych potwierdzonych przez dowolne centrum certyfikacji, a także certyfikatów samopodpisanych. Mechanizm podpisywania aplikacji nie ma większego znaczenia
z punktu widzenia bezpieczeństwa systemu. Jedyną korzyścią jaką wnosi jest potwierdzenie tożsamości autora instalowanej aplikacji. W przyszłości system podpisywania
może zostać wykorzystany w celu ograniczenia dostawców aplikacji do jedynie uprzednio zweryfikowanych, podobnie jak to jest w przypadku konkurencyjnego iPhone'a firmy Apple.
W obecnych wydaniach systemu Android funkcjonalność taka nie jest zaimplementowana.

Mechanizm podpisywanie aplikacji umożliwia programom współdzielenie zasobów, co zostało opisane w \ref{subsection:piaskownica}

\section{Narzędzia programistyczne}

Twórcy systemu Android udostępnili bardzo dobre narzędzia niezbędne do rozwijania i testowania aplikacji na ten system: SDK (Software Development Kit)
i NDK (Native Development Kit).

Android SDK jest podstawowym zestawem narzędzi przydatnym dla bardziej zaawansowanych użytkowników systemu oraz programistów . Najważniejsze komponenty tego pakietu to:
\begin{itemize}
\item emulator wraz z zestawem obrazów kolejnych wersji systemu pozwala uruchomić wirtualny obraz systemu. Możliwe jest zdefiniowanie 
sprzętowych parametrów emulowanego obrazu, m. in. rozmiar pamięci RAM, rozdzielczość i typ ekranu. Dzięki temu można wykonywać testy na wielu 
konfiguracjach. Wirtualizacja opiera się na emulatorze QEMU.
\item \verb+adb+ (Android Debug Bridge) - narzędzie umożliwiające komunikację z urządzeniem i debugowanie aplikacji. Pozwala wykonywać szereg czynności 
diagnostycznych, np. przesłanie pliku z/do urządzenia, wypisanie logów systemowych, uruchomienie konsoli, zainstalowanie/odinstalowanie aplikacji.
Narzędzie to może być także wykorzystywane do pracy z uruchomionym wirtualnym obrazem.
\item biblioteki dla kolejnych wydań systemu umożliwiają tworzenie aplikacji na daną platformę
\end{itemize}

Android NDK jest zestawem narzędzi dedykowanych dla systemu Android, który  został stworzony, aby umożliwić tworzenie aplikacji lub ich części w C/C++. 
W jego skład wchodzą między innymi:
\begin{itemize}
\item różne wersje kompilatora gcc dla wybranych architektur procesora (ARM, x86, ...).
\item standardowe narzędzia do debugowania i optymalizacji kodu, np. \verb+gdb+, \verb+gdbserver+, \verb+gcov+, \verb+ar+, \verb+ld+, \verb+objdump+.
\item pliki nagłówkowe i skompilowane statyczne i dynamiczne biblioteki, np. libc, libstdc++, libz, libm.
\end{itemize}

Obydwa pakiety posiadają bogatą dokumentację oraz zawierają liczne przykłady użycia. Przykłady w dalszej części pracy będą używały powyższych narzędzi.


\section{Aktualizacje systemu}\label{section:aktualizacje}

System Android posiada wbudowany mechanizm aktualizacji całego systemu. Jednak nowe wersje systemu są dostarczane przez producenta zazwyczaj ze sporym opóźnieniem. 
Wielu producentów urządzeń wraz ze standardową dystrybucją systemu załącza dodatkowe oprogramowanie, np. \textit{HTC Sense} firmy HTC, nakładka graficzna 
\textit{TouchWiz} firmy Samsung. Źródła systemu zazwyczaj są nieznacznie modyfikowane przez producenta dla każdego modelu telefonu, gdyż wymagają, np. dodatkowych 
sterowników urządzeń. Niektóre telefony posiadają także dodatkowe oprogramowanie operatora telefonii komórkowej.
Nowe wersje systemu w pierwszej kolejności pojawiają się na urządzeniach z linii \textit{Google Nexus}, ponieważ nie zawierają one żadnych dodatkowych rozszerzeń
producenta, ani firm telekomunikacyjnych. Bardzo wiele modeli nie otrzymuje dalszego wsparcia ze strony producenta. Jest to głównie spowodowane niewystarczającą 
platformą sprzętową danego modelu. Bywa także, że decyzja o zaprzestaniu wydawania aktualizacji ma przyczyny biznesowe i producent nie ponosi nakładów, na mało 
popularne urządzenia.

Tabela \ref{table:zasieg} przedstawia udział najpopularniejszych wersji systemu. Zauważyć można, że największy udział mają wersje, których data premiery miała miejsce 
ponad dwa lata temu.

\begin{table}
\begin{minipage}{\textwidth}
\centering
\begin{tabular}{|l|l|l|}
\hline\hline
Wersja	& Nazwa kodowa	& Udział	\\ 
\hline
2.1	& Eclair	& 1.7\%	\\
2.2	& Froyo	& 4.0\%	\\
2.3.3 - 2.3.7	& Gingerbread	& 39.7\%	\\
4.0.3 - 4.0.4	& Ice Cream Sandwich	& 29.3\%	\\
4.1.x	& Jelly Bean	& 23.0\%	\\
4.2.x	& Jelly Bean	& 2.0\%	\\
\hline
\end{tabular}
\caption[Udział wersji systemu Android]{Udział wersji systemu Android\protect\footnotemark (stan na 02-04-2013)}
\label{table:zasieg}
\footnotetext{źródło: \url{http://developer.android.com/about/dashboards/index.html}}
\end{minipage}
\end{table}

\chapter{Techniki ataków i sposoby na przeciwdziałanie}
 % protokól wywołanie funkcji

\section{Klasyczny błąd przepełnienie bufora}

% przeciwdziałanie: Stack smashing protection

\section{Technika ,,heap spray''}

%przeciwdziałanie: DEP, NX bit, Executable space protection

\subsection{NX bit}

W celu ochrony przed tego typu takimi w wersji 6 architektury ARM wprowadzona została technologia NX bit (No Execute). Umożliwia ona systemowi operacyjnemu 
oznaczyć wybrane strony pamięci jako niewykonywalne. Gdy bit NX dla danej strony jest ustawiony, próba wykonania zawartości tej strony jako kodu kończy się 
wygenerowaniem wyjątku, zgłaszanego systemowi operacyjnemu, co powoduje przerwanie wykonywania programu. Bit NX powinien być ustawiony dla wszystkich stron procesu, 
z wyjątkiem programu i bibliotek oraz świadomie dozwolonych przez program wyjątków.

Technologia ,,NX bit'' jest wspierana przez Androida od wersji 2.3. 




 wyko dzięki któremu system operacyjny 

\section{Technika ,,return to library'' (Ret2Libc)}

% przeciwdziałanie: ASLR

\chapter{Tworzenie payloadów}


\chapter{Przykłady ataków i ich implementacja w narzędziu Metasploit}

% ogolnie opisać matesploita, 
% materiały: 
%  praca dla samsunga
%  msf_user_guide.pdf

\section{CVE-2010-1119}

\section{CVE-2010-1807}

\chapter{Podsumowanie}

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

% troche nie na temat
\bibitem[1]{decomp} Anthony Desnos, Geoffroy Gueguen \textit{Android: From Reversing to Decompilation}, Black Hat, Abu Dhabi, 2011 \

\bibitem[2]{privescal} S. Höbarth, R. Mayrhofer, \textit{A framework for on-device privilege escalation exploit execution on android}, IWSSI/SPMU 2011: 3rd International Workshop on Security and Privacy in Spontaneous Interaction and Mobile Phone Use, colocated with Pervasive 2011, czerwiec 2011. dostępne na \url{http://www.medien.ifi.lmu.de/iwssi2011/} \

\bibitem[3]{armguide} Gaurav Kumar, Aditya Gupta, \textit{A Short Guide on ARM Exploitation}, \url{http://www.exploit-db.com/wp-content/themes/exploit/docs/24493.pdf} \

\bibitem[4]{alphanum} Yves Younan, Pieter Philippaerts, \textit{Alphanumeric RISC ARM shellcode}, Phrack, 66, czerwiec 2009 \

\bibitem[5]{anatomy} Joshua Hulse, \textit{Buffer Overflows: Anatomy of an Exploit}, \url{http://packetstormsecurity.com/files/108549/Buffer-Overflows-Anatomy-Of-An-Exploit.html} \

\bibitem[6]{explarm} Emanuele Acri, \textit{Exploiting Arm Linux Systems}, \url{http://packetstormsecurity.com/files/98376/Exploiting-ARM-Linux-Systems.html} \

\bibitem[7]{fuzzphone} Collin Mulliner, Charlie Miller, \textit{Fuzzing the Phone in your Phone}, Black Hat USA, 2009 \

\bibitem[8]{howtoshell} Jonathan Salwan, \textit{How to Create a Shellcode on ARM Architecture}, \url{http://www.exploit-db.com/papers/15652/} \

\bibitem[9]{telephony} Dustin ,,I)ruid'' Trammel, \textit{Metasploit Framework Telephony}, Black Hat USA, 2009 \

\bibitem[10]{nonexec} Itzhak Avraham, \textit{Non-Executable Stack ARM Exploitation}, Black Hat DC, 2011 \

\bibitem[11]{smashing} jip@soldierx.com, \textit{Stack Smashing On A Modern Linux System}, \url{http://www.soldierx.com/tutorials/Stack-Smashing-Modern-Linux-System} \

\bibitem[12]{armman} ARM Ltd. \textit{Arm architecture reference manual.} \

\bibitem[13]{armcall} ARM Ltd. \textit{Procedure call standard for the arm architecture.} \

\bibitem[14]{metasploit} Metasploit framework, \url{http://www.metasploit.com} \

\bibitem[15]{android} Android project, \url{http://developer.android.com} \

\bibitem[16]{webkit} The WebKit Open Source Project, \url{http://www.webkit.org} \

\end{thebibliography}

\end{document}

